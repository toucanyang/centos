PCRE2开源正则表达式库
PCRE2是Perl兼容正则表达式版本2的缩写。它是广受欢迎的PCRE库的继承者。两者都是Philip Hazel用C编写的开源库。
PCRE2的第一个发行版的版本号为10.00，以与先前的PCRE 8.36明确区分。PCRE 8.37到8.39及以后的任何PCRE版本都仅限于错误修复。新功能仅添加到PCRE2。如果您要进行新的开发项目，则应考虑使用PCRE2而不是PCRE。但是对于已经使用PCRE的现有项目，最好坚持使用PCRE。从PCRE迁移到PCRE2需要对源代码进行重大更改。这样做的唯一真实原因是使用新的搜索和替换功能。
PHP 7.3.0从PCRE移至PCRE2，但未使用新的PCRE2搜索和替换。它继续使用PHP自己的替换文本语法。
PCRE2 10.00至10.21和PCRE 8.36至8.39支持的正则表达式语法几乎相同。因此，该网站上的正则表达式教程没有特别提及PCRE2。关于PCRE的所有内容（尤其是PCRE版本8.36至8.39）也适用于PCRE2。
唯一重要的新功能是有条件的新版本检查。语法看起来很像是一个条件检查条件，它检查命名的反向引用，但是包含等号（以及捕获组名中不允许的其他符号）使它在原始PCRE中成为语法错误。在PCRE2的所有版本中，（？（VERSION> = 10.00）yes | no ）匹配字符串yesno中的yes。您可以对“是”和“否”部分使用任何有效的正则表达式。如果版本检查成功，则尝试“是”部分。否则，尝试“否”部分。这就像正常条件一样，根据捕获组是否参加比赛来评估竖线之前或之后的部分。
您可以使用> =检查最低版本，或使用=检查特定版本。 （？（VERSION = 10.00）yes | no ）与PCRE2 10.00 中的yes相匹配。它匹配任何在PCRE2 10.10和所有更高版本。省略次要版本号与指定.00相同。因此（？（VERSION> = 10）yes | no ）在所有版本的PCRE2中都匹配yes，但是（？（VERSION = 10）yes | no ）仅匹配yes在PCRE2 10.00中。如果指定次要版本号，则应在小数点后使用两位数。从10.21版开始，三个或三个以上的数字是错误。版本10.21还更改了单个数字的解释，包括以前导零指定的数字。由于第一个版本为10.00，第二个版本为10.10，因此无需检查单个数字。如果指定次要版本号，则不能省略该点。 （？（VERSION> = 1000）yes | no ）检查版本1000.00或更高。
此版本检查条件主要用于通过使用基于PCRE2提供正则表达式支持的应用程序或嵌入PCRE2但不公开其所有功能调用的编程语言来间接使用PCRE2的人员。它允许他们找出应用程序使用哪个版本的PCRE2。如果要使用PCRE2 C库开发应用程序，则应使用函数调用来确定PCRE2版本：
字符版本[255];
pcre2_config（PCRE2_CONFIG_VERSION，版本）;

UTF-8，UTF-16或UTF-32
在原始的PCRE库中，通过以pcre16_和pcre32_为前缀的附加功能在更高版本中添加了对UTF-16和UTF-32的支持。在PCRE2中，所有功能均以pcre2_开头，并以_8，_16或_32作为后缀，以选择8位，16位或32位代码单元。如果从源代码编译PCRE2，则需要将--enable-pcre2-16和--enable-pcre2-32传递到配置脚本，以确保_16和_32函数可用。
8位，16位或32位代码单元意味着PCRE2将您的字符串解释为由单字节字符，双字节字符或四字节字符组成。要使用UTF-8，UTF-16或UTF-32，您需要使用具有相应代码单元大小的函数，并将PCRE2_UTF选项传递给pcre2_compile以允许字符包含多个代码单元。UTF-8字符由1到4个字节组成。UTF-16字符由1或2个字组成。
如果要不带任何后缀调用PCRE2函数，如下所示，则需要将PCRE2_CODE_UNIT_WIDTH定义为8、16或32，以使不带后缀的函数使用8位，16位或32位。位代码单位。在包含库之前，请执行以下操作：
＃定义PCRE2_CODE_UNIT_WIDTH 8
#include“ pcre2.h”
不带后缀的功能始终使用您定义的代码单元大小。带后缀的功能仍然可用。因此，您的应用程序可以使用所有三种代码单元大小的正则表达式。但是重要的是不要将它们混淆。如果需要将同一正则表达式与UTF-8和UTF-16字符串进行匹配，则需要使用pcre_compile_8和pcre_compile_16对其进行两次编译，然后将编译后的正则表达式与相应的pcre_match_8和pcre_match_16函数一起使用。

使用PCRE2
使用PCRE2比使用PCRE更为复杂。使用PCRE2，您必须使用各种类型的上下文来传递某些编译或匹配选项，例如换行处理。在PCRE中，这些选项可以在编译或匹配时直接作为选项位传递。
在使用正则表达式之前，需要将其转换为二进制格式以提高效率。为此，只需调用pcre2_compile（）即可将正则表达式作为字符串传递。如果字符串以空值结尾，则可以传递PCRE2_ZERO_TERMINATED作为第二个参数。否则，以代码单位传递长度作为第二个参数。对于UTF-8，这是字节长度，而对于UTF-16或UTF-32，这是字节长度除以2或4。第三个参数是一组与二进制或组合的选项。您应该包括PCRE2_UTF，以获得适当的UTF-8，UTF-16或UTF-32支持。如果省略它，则将获得纯8位或UCS-2或UCS-4字符处理。其他常见选项是PCRE2_CASELESS，PCRE2_DOTALL，PCRE2_MULTILINE等。第4和第5参数接收错误条件。最后一个参数是上下文。除非需要特殊的换行符处理，否则传递NULL。该函数返回指向其分配的内存的指针。完成正则表达式后，必须使用pcre2_code_free（）释放它。
如果需要非默认的换行符处理，则需要调用pcre2_compile_context_create（NULL）创建新的编译上下文。然后调用pcre2_set_newline（）并传递该上下文和选项之一，例如PCRE2_NEWLINE_LF或PCRE2_NEWLINE_CRLF。然后将此上下文作为最终参数传递给pcre2_compile（）。您可以根据需要将相同的上下文重用于许多正则表达式编译。完成后，调用pcre2_compile_context_free（）。请注意，在原始PCRE中，您可以将PCRE_NEWLINE_LF等直接传递给pcre_compile（）。这不适用于PCRE2。如果将PCRE2_NEWLINE_LF等传递给pcre2_compile（），PCRE2将不会抱怨。但是这样做没有效果。您必须使用匹配上下文。
在使用编译的正则表达式查找字符串中的匹配项之前，需要调用pcre2_match_data_create_from_pattern（）分配内存以存储匹配结果。将编译后的正则表达式作为第一个参数传递，并将NULL作为第二个参数传递。该函数返回指向其分配的内存的指针。匹配数据完成后，必须使用pcre2_match_data_free（）释放它。您可以将相同的匹配数据重复用于pcre2_match（）的多个调用。
要找到匹配项，请调用pcre2_match（）并传递已编译的正则表达式，主题字符串，整个字符串的长度，匹配尝试必须开始的字符的偏移量，匹配选项，指向匹配数据对象的指针，以及上下文为NULL。长度和起始偏移量以代码单位而非字符为单位。匹配成功时，该函数返回一个正数。PCRE2_ERROR_NOMATCH表示未找到匹配项。任何其他非正返回值都表示错误。可以使用pcre2_get_error_message（）获得错误消息。
要找出字符串的哪一部分匹配，请调用pcre2_get_ovector_pointer（）。这将返回一个指向PCRE2_SIZE值数组的指针。您不需要释放该指针。当您调用pcre2_match_data_free（）时，它将变为无效。数组的长度是pcre2_match（）返回的值。数组中的前两个值是整体匹配的开始和结束。第二对是第一个捕获组的匹配，依此类推。如果您的正则表达式已命名捕获组，请致电pcre2_substring_number_from_name（）以获取组号。
如果只想获取匹配的文本，则可以使用便捷功能，例如pcre2_substring_copy_bynumber（）或pcre2_substring_copy_byname（）。传递捕获组的编号或名称，或为整体匹配传递零。使用pcre2_substring_free（）释放结果。如果结果不需要以零结尾，则可以使用pcre2_substring_get_bynumber（）和pcre2_substring_get_byname（）获得指向原始主题字符串内比赛开始的指针。pcre2_substring_length_bynumber（）和pcre2_substring_length_byname（）为您提供匹配的长度。
PCRE2不提供给您字符串中正则表达式的所有匹配项的功能。它的返回值永远不会超过第一个匹配项。要获得第二个匹配项，请再次调用pcre2_match（）并传递ovector [1]（第一个匹配项的结尾）作为第二个匹配尝试的起始位置。如果第一个匹配为零长度，则将PCRE2_NOTEMPTY_ATSTART包含在传递给pcre2_match（）的选项中，以避免再次找到相同的零长度匹配。这与增加呼叫前的开始位置不同。使用PCRE2_NOTEMPTY_ATSTART传递上一个匹配项的末尾可能会导致在同一位置找到非零长度的匹配项。

替代比赛
PCRE的愿望清单上永远存在的最大物品可能是搜索和替换的能力。PCRE2最终交付。替换字符串的语法非常简单。但是，没有与Perl兼容的东西。反向引用可以指定为$ group或$ {group}，其中“ group”是组的名称或编号。总体匹配为组编号零。要将文字美元符号添加到替换中，您需要将其加倍。不属于有效反向引用的任何单个美元符号都是错误。与Python一样，但与Perl不同，PCRE2将对不存在的组的反向引用和对不参与的组的反向引用视为错误。反斜杠是文字。
在替换匹配项之前，您需要使用pcre2_compile（）编译正则表达式。您可以将相同的已编译正则表达式用于正则表达式匹配和正则表达式替换。您不需要匹配数据对象来进行替换。
调用pcre2_substitute（）并将经过编译的正则表达式，主题字符串，主题字符串的长度，字符串中应进行正则表达式匹配的位置以及匹配选项传递给它。您可以将PCRE2_SUBSTITUTE_GLOBAL包含在匹配选项中，以替换起始位置之后的所有匹配，而不仅仅是第一匹配。下一个参数用于匹配数据和匹配上下文，它们都可以设置为NULL。然后传递替换字符串和替换字符串的长度。最后，传递指向应该存储结果字符串的缓冲区的指针，以及指向保存缓冲区大小的变量的指针。缓冲区需要有一个空间来终止零。所有长度和偏移量均以代码单位而非字符为单位。
pcre2_substitute（）返回被替换的正则表达式匹配数。零表示未找到匹配项。此函数从不返回PCRE2_ERROR_NOMATCH。负数表示发生错误。调用pcre2_get_error_message（）获取错误消息。保留缓冲区大小的变量将更新，以指示它写入缓冲区的字符串的长度，不包括结尾的零。（终止的零被写入。）
￼
扩展替换字符串语法
从版本10.21开始，PCRE2提供了扩展的替换字符串语法，您可以通过在调用pcre2_substitute（）时将PCRE2_SUBSTITUTE_EXTENDED与匹配选项一起包括在内来启用。最大的区别是反斜杠不再是文字。反斜杠后跟不是字母或数字的字符会转义该字符。因此，您可以避开美元符号和反斜杠以及其他反斜杠来抑制其特殊含义。如果要在替换中使用原义的反斜杠，则必须使用另一个反斜杠对其进行转义。反斜杠后跟数字是错误。除非该组合形成替换字符串标记，否则反斜杠后跟字母是错误。
\ a， \ e， \ f， \ n， \ r和 \ t是通常的ASCII控制字符转义符。明显缺少的是 \ b和 \ v。 \ x0到 \ xF和 \ x00到 \ xFF是十六进制转义。 \ x {0}至 \ x {10FFFF}插入Unicode代码点。 \ o {0}至 \ o {177777}是八进制转义。
还支持大小写转换。语法与Perl相同，但行为不同。Perl允许您将\ u或\ l与\ L或\ U结合使用，以使一个字符大写或小写，而其余字符则相反。使用PCRE2，任何大小写转换转义都会取消前面的转义。因此，您无法将它们组合在一起，甚至\ u或\ l都将结束\ U或\ L的运行。
使用新发明的语法支持条件，该语法扩展了反向引用的语法。 $ {组：+ 匹配：无与伦比}插入匹配当组参加和无与伦比的，当它没有。您可以在两个替代方案中使用完整的替换字符串语法，包括其他条件。
大小写转换通过条件进行。条件之前生效的任何大小写转换也适用于条件。如果条件包含其自己的案例，转换将在实际使用的条件部分中转义，那么条件转换之后这些条件仍然有效。因此，您可以使用$ {1：+ \ U ：\ L } $ {2}来插入与第二个捕获组匹配的文本（如果第一个捕获组参与的话则以大写字母插入，如果没有，则以小写插入）。
做捐献
这个网站是否为您节省了前往书店的旅程？请捐款支持该网站，您将终生获得无广告访问该网站的机会！
| 快速入门 | 教程 | 工具和语言 | 例子 | 参考 | 书评  |
| grep | PowerGREP | RegexBuddy | RegexMagic  |
| EditPad Lite | EditPad Pro  |
| 提升 | 德尔福 | GNU（Linux） | Groovy | Java | JavaScript | .NET | PCRE（C / C ++） | PCRE2（C / C ++） | Perl | PHP | POSIX | PowerShell | Python | R | 红宝石 | std :: regex | Tcl | VBScript | Visual Basic 6 | wxWidgets | XML模式 | Xojo |XQuery和XPath | XRegExp  |
